{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2e3b42d9_758eb1e7",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:01:15Z",
      "side": 1,
      "message": "ah, you made this global variable which means this task will not die till this goes out of scope, not sure if another task is assigned to this the earlier one goes out of scope.",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89e12809_649f9d9b",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:07:05Z",
      "side": 1,
      "message": "@matt\nwe in openbmc do not support threads (not sure why though) but we support fork, can we allow usage of std::async as used in the above code? also the std::future was declared as global variable to force it to not to go out of scope(if it goes out of scope the thread used in std::async will be detached), will that have any other issues. Or there any other better alternatives? coroutines?",
      "parentUuid": "2e3b42d9_758eb1e7",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a7ec13a_0539b5aa",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-03T14:16:43Z",
      "side": 1,
      "message": "The delete from host is a asyng operation as we dont wait for the result. the entry on the BMC is already deleted so nobody can make another delete call on this entry.\n\nA simple fork wont work because, the delete function is making dbus call and the forked child was not getting the bus as seen earlier.\n\nif std::future is declared locally then it is synchronized operation, the caller will have to wait until the completion of the async operation.",
      "parentUuid": "89e12809_649f9d9b",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9421554_bcfba931",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2022-02-03T14:19:49Z",
      "side": 1,
      "message": "Multithreading is definitely allowed when necessary.  I see other users of futures and std::async in openbmc.  I\u0027m not familiar enough with coroutines yet to put in a plug for those, though I don\u0027t imagine they would be more straightforward than what you have here.  So I don\u0027t have an issue with what you did here.",
      "parentUuid": "89e12809_649f9d9b",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f26100c_a3f3a80a",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-02-03T15:14:33Z",
      "side": 1,
      "message": "\u003e we in openbmc do not support threads (not sure why though) \n\nbecause using threads is bug prone and wastes resources when compared to async/event-loop based programming.\n\n\u003e but we support fork\n\nI hope we are not forking processes as an alternative to using threads.  forking doesn\u0027t make sense here.\n\n\u003e Multithreading is definitely allowed when necessary. \n\nIt is rarely necessary IMO.\n\n\u003e I see other users of futures and std::async in openbmc.\n\nThis isn\u0027t justification on its own.\n\nIt seems like we are going to tell the client the dump has been deleted before it is actually deleted.  You can accomplish the same thing without threads by simply calling pldm_send instead of pldm_send_recv.  If you want to log an error if the delete fails, you can add the response fd to your event loop.\n\nIdeally we would not give the caller a response until the job is actually done.  neither of these approaches (the one taken in the patch or my alternative suggestion) don\u0027t give the caller any way to figure out if their call worked or not.  That just isn\u0027t a good interface.\n\nTo provide a good interface that allows the caller to know if the operation was successful or not there are a couple options.  Unfortunately none of them are easy.\n\n1 - switch this program to sdbusplus asio.  that allows you make your pldm calls _and_ delay your response to the delete client.\n2 - come up with an async delete dbus interface that returns a task object and implement that.\n3 - add or wait-for support to phosphor-dbus-interfaces that lets you delay your response to the delete client while you do other IPC.",
      "parentUuid": "b9421554_bcfba931",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc6e0e88_154eb6c7",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-03T15:26:44Z",
      "side": 1,
      "message": "| it seems like we are going to tell the client the dump has been deleted before it is actually deleted.  You can accomplish the same thing without threads by simply calling pldm_send instead of pldm_send_recv.\n \nEven to call pldm_send a dbus call needs to be made to PLDM to get the instance id. \n\nIt was always the entry was deleted and send message to PHYP to delete the actual entry.\n\nThe problem here is blocking dbus call.. let me look at sdbusplus asio whether than can eliminate the blocking",
      "parentUuid": "2f26100c_a3f3a80a",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "823a81dd_8630650b",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-04T07:14:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cc6e0e88_154eb6c7",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cb6b81a_1dcdf05b",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:18:32Z",
      "side": 1,
      "message": "probably we should do this to clear if there is any earlier allocated thread.\nif (asyncThread.valid())\n{\n  asyncThread.get();\n}\n\n@matt",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20580b35_e025da57",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:30:41Z",
      "side": 1,
      "message": "https://bartoszmilewski.com/2011/10/10/async-tasks-in-c11-not-quite-there-yet/\n\nHans Boehm clarified the termination requirement for tasks: Thread-local variables must be fully destroyed before the owning thread returns from calling get or wait on a future produced by the corresponding std::async; or before the destructor of that future returns, whichever comes first.\n\nhere destructor is not called on the global future rater operator\u003d",
      "parentUuid": "1cb6b81a_1dcdf05b",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18a19a2f_7ea4d52d",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-03T14:47:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "20580b35_e025da57",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}