{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2e3b42d9_758eb1e7",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:01:15Z",
      "side": 1,
      "message": "ah, you made this global variable which means this task will not die till this goes out of scope, not sure if another task is assigned to this the earlier one goes out of scope.",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89e12809_649f9d9b",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:07:05Z",
      "side": 1,
      "message": "@matt\nwe in openbmc do not support threads (not sure why though) but we support fork, can we allow usage of std::async as used in the above code? also the std::future was declared as global variable to force it to not to go out of scope(if it goes out of scope the thread used in std::async will be detached), will that have any other issues. Or there any other better alternatives? coroutines?",
      "parentUuid": "2e3b42d9_758eb1e7",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a7ec13a_0539b5aa",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-03T14:16:43Z",
      "side": 1,
      "message": "The delete from host is a asyng operation as we dont wait for the result. the entry on the BMC is already deleted so nobody can make another delete call on this entry.\n\nA simple fork wont work because, the delete function is making dbus call and the forked child was not getting the bus as seen earlier.\n\nif std::future is declared locally then it is synchronized operation, the caller will have to wait until the completion of the async operation.",
      "parentUuid": "89e12809_649f9d9b",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9421554_bcfba931",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2022-02-03T14:19:49Z",
      "side": 1,
      "message": "Multithreading is definitely allowed when necessary.  I see other users of futures and std::async in openbmc.  I\u0027m not familiar enough with coroutines yet to put in a plug for those, though I don\u0027t imagine they would be more straightforward than what you have here.  So I don\u0027t have an issue with what you did here.",
      "parentUuid": "89e12809_649f9d9b",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cb6b81a_1dcdf05b",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:18:32Z",
      "side": 1,
      "message": "probably we should do this to clear if there is any earlier allocated thread.\nif (asyncThread.valid())\n{\n  asyncThread.get();\n}\n\n@matt",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20580b35_e025da57",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000089
      },
      "writtenOn": "2022-02-03T14:30:41Z",
      "side": 1,
      "message": "https://bartoszmilewski.com/2011/10/10/async-tasks-in-c11-not-quite-there-yet/\n\nHans Boehm clarified the termination requirement for tasks: Thread-local variables must be fully destroyed before the owning thread returns from calling get or wait on a future produced by the corresponding std::async; or before the destructor of that future returns, whichever comes first.\n\nhere destructor is not called on the global future rater operator\u003d",
      "parentUuid": "1cb6b81a_1dcdf05b",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18a19a2f_7ea4d52d",
        "filename": "dump-extensions/openpower-dumps/resource_dump_entry.cpp",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1000084
      },
      "writtenOn": "2022-02-03T14:47:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "20580b35_e025da57",
      "revId": "a9529bb007e926e65e0ed1dd7b29c814ca3326d0",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}