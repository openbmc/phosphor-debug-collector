#! /bin/bash
# shellcheck disable=SC2034  # Variable is used elsewhere
help=$(cat << EOF
        opdreport creates an archive consisting of the following:
                * host dump files and header applied on top of it
        The type parameter controls the content of the data. The generated
        archive is stored in the user specified location.

usage: opdreport [OPTION]

Options:
        -n, —-name <name>     Name to be used for the archive.
                              Default name format
                              SYSDUMP.<serial number>.<dump_id>.<time>
                              Optional parameter.
        -d, —-dir <directory> Archive directory to copy the compressed report.
                              Default output directory is current working
                              directory. Optional parameter.
        -i, —-dumpid <id>         Dump identifier to associate with the archive.
                              Identifiers include numeric characters.
                              Default dump identifier is 0
        -s, --size <size>     Maximum allowed size(in KB) of the archive.
                              Report will be truncated in case size exceeds
                              this limit. Default size is unlimited.
        -f, --failingunit     The id of the failed unit
        -e, --eid             Error log associated with the failure
        -t, --type            Type of the dump to be collected
                              1  -  Hardware dump
                              3  -  Performance dump
                              5  -  Hostboot dump
                              10 -  SBE Dump
        -h, —-help            Display this help and exit.
EOF
)

#CONSTANTS
declare -rx OP_DUMP="opdump"
declare -rx DREPORT_SOURCE="/usr/share/dreport.d"
declare -rx TRUE=1
declare -rx FALSE=0
declare -rx TIME_STAMP="date -u"
declare -rx UNLIMITED="unlimited"
declare -rx DREPORT_INCLUDE="$DREPORT_SOURCE/include.d"
declare -rx INVENTORY_MANAGER='xyz.openbmc_project.Inventory.Manager'
declare -rx INVENTORY_PATH='/xyz/openbmc_project/inventory/system'
declare -rx INVENTORY_ASSET_INT='xyz.openbmc_project.Inventory.Decorator.Asset'
declare -rx INVENTORY_BMC_BOARD='/xyz/openbmc_project/inventory/system/chassis/motherboard'
declare -rx HEADER_EXTENSION="$DREPORT_INCLUDE/gendumpheader"
declare -rx FILE_SCRIPT="$DREPORT_SOURCE/include.d/gendumpinfo"
declare -rx TMP_DIR="/tmp"

#Error Codes
declare -rx SUCCESS="0"
declare -rx INTERNAL_FAILURE="1"
declare -rx RESOURCE_UNAVAILABLE="2"

#VARIABLES
declare -x dump_type="$OP_DUMP"
declare -x dump_sbe_type=100
declare -x size_dump=""
declare -x elog_id="00000000"
declare -x EPOCHTIME
EPOCHTIME=$(date +"%s")
declare -x name=""
declare -x dump_dir=$TMP_DIR
declare -x dump_id="00000000"
declare -x dump_size="unlimited"
declare -x content_path=""
declare -x name_dir=""
declare -x serialNo="0000000"
declare -x dDay
dDay=$(date -d @"$EPOCHTIME" +'%Y%m%d%H%M%S')
declare -x dump_content_type=""
declare -x FILE=""

# @brief get serial number property from inventory
function fetch_serial_number() {
    serialNo=$(busctl get-property $INVENTORY_MANAGER $INVENTORY_PATH \
        $INVENTORY_ASSET_INT SerialNumber | cut -d " " -f 2 | sed "s/^\(\"\)\(.*\)\1\$/\2/g")

    if [ -z "$serialNo" ]; then
        serialNo="0000000"
    fi
}

# @brief Check the validity of user inputs and initialize global
#        variables.
# @return 0 on success, error code otherwise
function initialize()
{
    #Dump file name
    # shellcheck disable=SC2154 # name comes from elsewhere
    if [ -z "$name" ]; then
        name="SYSDUMP"
    fi
    fetch_serial_number
    # shellcheck disable=SC2154 # dump_id comes from elsewhere
    id=$(printf %08d $dump_id)
    name="${name}.${serialNo}.${id}.${dDay}"

    #Source files path
    if [ -z "$dump_sbe_type" ]; then
        echo "Error: Dump type is not provided."
        return "$RESOURCE_UNAVAILABLE";
    fi

    #Destination path
    # shellcheck disable=SC2154 # dump_dir comes from elsewhere
    if [ -z "$dump_dir" ]; then
        dump_dir=$PWD
    fi

    #Size
    #Check the input is integer.
    # shellcheck disable=SC2154 # dump_size comes from elsewhere
    if [ "$dump_size" -eq "$dump_size" ] 2>/dev/null; then
        #Converts in to bytes.
        dump_size="$((dump_size * 1024))"
    else
        dump_size=$UNLIMITED
    fi
    return "$SUCCESS"
}

# @brief collect the dump
function collect()
{
    content_path="$TMP_DIR/dump_${dump_id}_${EPOCHTIME}"
    dump_outpath="$content_path/plat_dump"
    if ! mkdir -p "$dump_outpath" ; then
        echo "Could not create the destination directory $dump_outpath"
        return "$INTERNAL_FAILURE"
    fi

    dump-collect --type $dump_sbe_type --id "$dump_id" --failingunit "$failing_unit" --path "$dump_outpath"
}

# @brief Packaging the dump and transferring to dump location.
function package()
{
    # shellcheck disable=SC2154 # dump_id populated
    FILE="$TMP_DIR/dumpheader_${dump_id}_${EPOCHTIME}"
    if ! mkdir -p "$dump_dir" ; then
        echo "Could not create the destination directory $dump_dir"
        dump_dir="/tmp"
    fi

    cd "$content_path" || exit

    dump_content_type=${dump_id:0:2}

    ("$FILE_SCRIPT")

    elog_id=eid

    tar -cvzf "$name" plat_dump/*Sbe* info.yaml
    # shellcheck disable=SC2181 # need output from `tar` in above if cond.
    if [ $? -ne 0 ]; then
        echo "$($TIME_STAMP)" "Could not create the compressed tar file"
        return "$INTERNAL_FAILURE"
    fi

    #Fetching the size of the file
    size_dump=$(stat -c %s "$name")

    if [ "$dump_size" != "$UNLIMITED" ] && [ "$size_dump" -gt "$dump_size" ]; then
        rm "$name"
        return "$RESOURCE_UNAVAILABLE"
    fi

    echo "Adding Dump Header :""$HEADER_EXTENSION"
    ("$HEADER_EXTENSION")
    #Applying header to the file
    # shellcheck disable=SC2002
    cat "$name" | tee -a "$FILE" > /dev/null
    mv "$FILE" "$name"
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
        echo "$($TIME_STAMP)" "Could not create the compressed file"
        rm -rf "$name" "$FILE"
        return "$INTERNAL_FAILURE"
    fi

    mv "$name" "$dump_dir"

    rm -rf "$content_path"
    rm -rf "$FILE" "$name"

    return "$SUCCESS"
}

# @brief Main function
function main()
{
    #initialize the global variables and checks for user provided data
    initialize
    result=$?
    if [[ ${result} -ne $SUCCESS ]]; then
        echo "$($TIME_STAMP)" "Error: Failed to initialize, Exiting"
        exit;
    fi

    #Collect the dump
    collect
    result=$?
    if [[ ${result} -ne $SUCCESS ]]; then
        echo "$($TIME_STAMP)" "Error: Failed to collect dump, Exiting"
        exit;
    fi

    package  #package the dump
    result=$?
    if [[ ${result} -ne $SUCCESS ]]; then
        echo "$($TIME_STAMP)" "Error: Failed to package, Exiting"
    else
        echo "$($TIME_STAMP)" "Successfully completed"
        exit;
    fi
}

# shellcheck disable=SC2034  # Variable is used elsewhere
TEMP=$(getopt -o n:d:i:s:t:e:f:h \
        --long name:,dir:,dumpid:,size:,type:,eid:,failingunit:,help \
    -- "$@")

# shellcheck disable=SC2181
if [ $? -ne 0 ]
then
    echo "Error: Invalid options"
    exit 1
fi

eval set -- "$TEMP"

while [[ $# -gt 1 ]]; do
    key="$1"
    case $key in
        -n|--name)
            name=$2
            shift 2 ;;
        -d|--dir)
            dump_dir=$2
            shift 2 ;;
        -i|--dumpid)
            dump_id=$2
            shift 2 ;;
        -s|--size)
            dump_size=$2
            shift 2 ;;
        -f|--failingunit)
            failing_unit=$2
            shift 2 ;;
        -e|--eid)
            eid=$2
            shift 2 ;;
        -t|--type)
            dump_sbe_type=$2
            shift 2 ;;
        -h|--help)
            echo "$help"
            exit ;;
        *) # unknown option
            echo "Unknown argument: $1"
            echo  "$help"
            exit 1 ;;
    esac
done

main #main program
exit $?
