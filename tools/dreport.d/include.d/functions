#!/usr/bin/env bash

# @brief Execute the command and save the output into the dreport
#        packaging, if it is in the user allowed dump size limit.
# @param $1 Command to be executed.
# @param $2 Save file name.
# @param $3 Plugin description used for logging.
function add_cmd_output()
{
    command="$1"
    file_name="$2"
    desc="$3"

    eval $command >> "$name_dir/$file_name"
    if [ $? -ne 0 ]; then
        log_error "Failed to collect $desc"
        rm -f "$name_dir/$file_name"
        return 1
    fi

    if check_size "$name_dir/$file_name"; then
        log_info "Collected $desc"
    else
        log_warning "Skipping $desc"
    fi
}

# @brief Copy the file or directory into the dreport packaging,
#        if it is in the user allowed dump size limit.
# @param $1 Copy file or directory name.
# @param $2 Plugin description used for logging.
function add_copy_file()
{
    file_name="$1"
    desc="$2"

    cp -Lr $file_name $name_dir
    if [ $? -ne 0 ]; then
        log_error "Failed to copy $desc $file_name"
        rm -fr "$name_dir/$file_name"
        return $RESOURCE_UNAVAILABLE
    fi
    if check_size "$name_dir/$(basename "$file_name")"; then
        log_info "Copied $desc $file_name"
        return $SUCCESS
    else
        log_warning "Skipping copy $desc $file_name"
        return $RESOURCE_UNAVAILABLE
    fi
}
# @brief Copy the symbolic link file to the dreport packaging,
#        if it is in the user allowed dump size limit.
# @param $1 symbolic link file name
# @param $2 Plugin description used for logging.
function add_copy_sym_link_file()
{
    file_name="$1"
    desc="$2"

    cp $file_name $name_dir
    if [ $? -ne 0 ]; then
        log_error "Failed to copy $desc $file_name"
        rm -fr "$name_dir/$file_name"
        return $RESOURCE_UNAVAILABLE
    fi
    if check_size "$name_dir/$(basename "$file_name")"; then
        log_info "Copied $desc $file_name"
        return $SUCCESS
    else
        log_warning "Skipping copy $desc $file_name"
        return $RESOURCE_UNAVAILABLE
    fi
}

# @brief Calculate file or directory compressed size based on input
#        and check whether the size in the allowed size limit.
#        Remove the file or directory from the name_dir
#        if the check fails.
# @param $1 Source file or directory
# @return 0 on success, error code if size exceeds the limit.
# Limitation: compress and tar will have few bytes size difference
function check_size()
{
    source=$1

    #No size check required in case dump_size is set to unlimited
    if [ $dump_size = $UNLIMITED ]; then
        return 0
    fi

    #get the file or directory size
    if [[ -d $source ]] && [[ -n $source ]]; then
        tar -cf "$source.tar" -C \
            $(dirname "$source") $(basename "$source")
        size=$(stat -c%s "$source.tar")
        rm "$source.tar"
    else
        size=$(stat -c%s "$source")
    fi

    if [ $((size + cur_dump_size)) -gt $dump_size ]; then
        #Exceed the allowed limit,
        #tar and compress the files and check the size
        tar -Jcf "$name_dir.tar.xz" -C \
            $(dirname "$name_dir") $(basename "$name_dir")
        size=$(stat -c%s "$name_dir.tar.xz")
        if [ $size -gt $dump_size ]; then
            #Remove the the specific data from the name_dir and continue
            rm "$source" "$name_dir.tar.xz"
            return $RESOURCE_UNAVAILABLE
        else
            rm "$name_dir.tar.xz"
        fi
    fi

    cur_dump_size=$((size + cur_dump_size))
    return $SUCCESS
}

# @brief log the error message
# @param error message
function log_error()
{
    echo $($TIME_STAMP) "ERROR: $*" >> $dreport_log
    if ((quiet != TRUE)); then
        echo $($TIME_STAMP) "ERROR: $*" >&2
    fi
}

# @brief log warning message
# @param warning message
function log_warning()
{
    if ((verbose == TRUE)); then
        echo $($TIME_STAMP) "WARNING: $*" >> $dreport_log
        if ((quiet != TRUE)); then
            echo $($TIME_STAMP) "WARNING: $*" >&2
        fi
    fi
}

# @brief log info message
# @param info message
function log_info()
{
    if ((verbose == TRUE)); then
        echo $($TIME_STAMP) "INFO: $*" >> $dreport_log
        if ((quiet != TRUE)); then
            echo $($TIME_STAMP) "INFO: $*" >&1
        fi
    fi
}

# @brief log summary message
# @param message
function log_summary()
{
    echo $($TIME_STAMP) "$*" >> $summary_log
    if ((quiet != TRUE)); then
        echo $($TIME_STAMP) "$*" >&1
    fi
}

#Function to get the Originator details
#for Originator Type and Originator ID
function get_originator_details() {
    if [ -z "$dump_dir" ]; then
        return
    fi

    # A hash map for each possible dump types
    # Add/Remove as per the requirement
    local -A dump_name_map
    dump_name_map["dumps"]="bmc"
    dump_name_map["faultlogs"]="faultlog"
    dump_name_map["hardwaredump"]="hardware"
    dump_name_map["hostbootdump"]="hostboot"
    dump_name_map["msbedump"]="msbe"
    dump_name_map["sbedump"]="sbe"

    dump_type=$(echo "$dump_dir" | cut -d'/' -f 5)
    dump_entry_id=$(echo "$dump_dir" | cut -d'/' -f 6)

    dump_type_extracted="$dump_type"

    for key in "${!dump_name_map[@]}"
    do
        if [ "$key" = "$dump_type" ]; then
            dump_type_extracted="${dump_name_map[$key]}"
            break
        fi
    done

    if [ "$dump_type_extracted" = "$dump_type" ]; then
        return "$SUCCESS"
    fi

    local DBUS_DUMP_MANAGER="xyz.openbmc_project.Dump.Manager"
    local DBUS_DUMP_PATH="/xyz/openbmc_project/dump/$dump_type_extracted/entry/$dump_entry_id"
    local DBUS_DUMP_ORIGINATROR_IFACE="xyz.openbmc_project.Common.OriginatedBy"
    local DBUS_ORIGINATOR_TYPE_STRING="OriginatorType"
    local DBUS_ORIGINATOR_ID_STRING="OriginatorId"

    ORIGINATOR_TYPE=$(busctl get-property "$DBUS_DUMP_MANAGER" "$DBUS_DUMP_PATH" \
        "$DBUS_DUMP_ORIGINATROR_IFACE" "$DBUS_ORIGINATOR_TYPE_STRING")

    ORIGINATOR_ID=$(busctl get-property "$DBUS_DUMP_MANAGER" "$DBUS_DUMP_PATH" \
        "$DBUS_DUMP_ORIGINATROR_IFACE" "$DBUS_ORIGINATOR_ID_STRING")

    ORIGINATOR_TYPE=$(echo "$ORIGINATOR_TYPE" | cut -d' ' -f 2 \
        | cut -d'.' -f 6 | cut -d'"' -f 1)

    ORIGINATOR_ID=$(echo "$ORIGINATOR_ID" | cut -d' ' -f 2 | cut -d'"' -f 1)

    # This hash map for Originator Type is populated based on
    # the info provided by the OriginatedBy.interface.yaml file under
    # https://github.com/openbmc/phosphor-dbus-interfaces/
    # Feel free to amend the table as per the evolving requirement
    local -A originator_type_enum_map
    originator_type_enum_map["Client"]=0
    originator_type_enum_map["Internal"]=1
    originator_type_enum_map["SupportingService"]=2

    local originator_type_maped="$ORIGINATOR_TYPE"
    for key in "${!originator_type_enum_map[@]}"
    do
        if [ "$key" = "$ORIGINATOR_TYPE" ]; then
            originator_type_maped="${originator_type_enum_map[$key]}"
            break
        fi
    done

    if [ "$originator_type_maped" = "$ORIGINATOR_TYPE" ]; then
        ORIGINATOR_TYPE=""
        return "$SUCCESS"
    else
        ORIGINATOR_TYPE="$originator_type_maped"
    fi

    return "$SUCCESS"
}
