#! /bin/bash

help=$"
        dreport creates an archive(xz compressed) consisting of the following:
                * Configuration information
                * Debug information
                * A summary report
        The type parameter controls the content of the data. The generated
        archive is stored in the user specified location.

usage: dreport [OPTION]

Options:
        -n, —-name <name>     Name to be used for the archive.
                              Default name format obmcdump_<id>_<epochtime>
        -d, —-dir <directory> Archive directory to copy the compressed report.
                              Default output directory is /tmp
        -i, —-id <id>         Dump identifier to associate with the archive.
                              Identifiers include numeric characters.
                              Default dump identifier is 0
        -t, —-type <type>     Data collection type. Valid types are
                              "user", "core".
                              Default type is "user" initiated.
        -f, —-file <file>     Optional file to be included in the archive.
                              Absolute path of the file must be passed as
                              parameter. This is useful to include application
                              core in the dump.
        -s, --size <size>     Maximum allowed size(in KB) of the archive.
                              Report will be truncated in case size exceeds
                              this limit. Default size is 500KB.
        -v, —-verbose         Increase logging verbosity.
        -V, --version         Output version information.
        -q, —-quiet           Only log fatal errors to stderr
        -h, —-help            Display this help and exit.
"

#CONSTANTS
declare -r TRUE=1
declare -r FALSE=0
declare -r UNLIMITED="unlimited"
declare -r SUMMARY_DUMP="summary"
declare -r UserRequested="1"
declare -r ApplicationCored="2"
declare -r TYPE_USER="user"
declare -r TYPE_CORE="core"
declare -r SUMMARY_LOG="summary.log"
declare -r DREPORT_LOG="dreport.log"
declare -r TMP_DIR="/tmp"
declare -r EPOCHTIME=$(date +"%s")

#Error Codes
declare -r SUCCESS="0"
declare -r INTERNAL_FAILURE="1"
declare -r RESOURCE_UNAVAILABLE="2"

#VARIABLES
declare -x name=""
declare -x dump_dir="/tmp"
declare -x dump_id="00000000"
declare -x dump_type=$UserRequested
declare -x verbose=$FALSE
declare -x quiet=$FALSE
declare -x dump_size="unlimited"
declare -x name_dir=""
declare -x optional_file=""
declare -x dreport_log=""
declare -x summary_log=""

# PACKAGE VERSION
PACKAGE_VERSION="0.0.1"

# @brief Initial version of the summary log
init_summary()
{
   log_summary "Version:       $PACKAGE_VERSION"
   log_summary "Name:          $name.tar.xz"
   log_summary "Epochtime:     $EPOCHTIME"
   log_summary "ID:            $dump_id"
   log_summary "Type:          $dump_type"
   log_summary "Optional file: $optional_file"
}

# @brief Check validitity of user inputs and initlize the
#        variables. Also create required storage space
# @return 0 on success, error code otherwise

function init_global()
{
    #Dump file name
    if [ -z $name ]; then
        name=$"obmcdump_"$dump_id"_$EPOCHTIME"
    fi

    #Create temporary data directory.
    mkdir -p "$TMP_DIR/$name"
    if [ $? -ne 0 ]; then
        echo "Error: Failed to create the temporary directory."
        return $RESOURCE_UNAVAILABLE;
    fi

    #name directory
    name_dir="$TMP_DIR/$name"

    #dreport log file
    dreport_log="$name_dir/$DREPORT_LOG"

    #summary log file
    summary_log="$name_dir/$SUMMARY_LOG"

    #Type
    key="$dump_type"
    case $key in
        $UserRequested | $TYPE_USER)
            dump_type=$TYPE_USER
            ;;
        $ApplicationCored | $TYPE_CORE)
           dump_type=$TYPE_CORE
           ;;
        *)
           log_error "Invalid -type, Reporting only summary log"
           dump_type=$SUMMARY_DUMP
           ;;
    esac

    #Size
    if [ "$dump_size" -eq "$dump_size" ] 2>/dev/null; then
       #Converts in to bytes.
       dump_size="$((dump_size * 1024))"
    else
       dump_size=$UNLIMITED
    fi

    return $SUCCESS
}

# @brief Packaging the dump and transferring to dump location.
function package()
{
    mkdir -p "$dump_dir"
    if [ $? -ne 0 ]; then
        log_error "Could not create the destination directory $dump_dir"
        dest_dir=$TMP_DIR
    fi

    #TODO openbmc/openbmc#1506 Enable file level compression.
    #tar and compress the files.
    tar_file="$name_dir.tar.xz"
    tar -Jcf "$tar_file" -C "$TMP_DIR" "$name"

    #remove the temporary name specific directory
    rm -r "$name_dir"

    #check the file size is in the allowed limit
    if [ $(stat -c%s "$tar_file") -gt $dump_size ]; then
       echo "File size exceeds the limit allowed"
       rm -rf "$TMP_DIR"
       exit 1
       #TODO openbmc/openbmc#1506 Revisit the error handling
    fi

    echo "Report is available in $dump_dir"

    if [ "$TMP_DIR" == "$dump_dir" ]; then
       return
    fi

    #copy the compressed tar file into the destination
    cp "$tar_file" "$dump_dir"
    if [ $? -ne 0 ]; then
        echo "Failed to copy the $tar_file to $dump_dir"
        return
    else
        rm -rf "$TMP_DIR"
    fi
}
# @brief log the error message
# @param error message
function log_error()
{
   echo "ERROR: $@" >>"$name_dir/$DREPORT_LOG"
   if ((quiet != TRUE)); then
      echo "ERROR: $@" >&2
   fi
}

# @brief log warning message
# @param warning message
function log_warning()
{
    if ((verbose == TRUE)); then
        echo "WARNING: $@" >>"$name_dir/$DREPORT_LOG"
        if ((quiet != TRUE)); then
            echo "WARNING: $@" >&2
        fi
    fi
}

# @brief log info message
# @param info message
function log_info()
{
    if ((verbose == TRUE)); then
        echo "INFO: $@" >>"$name_dir/$DREPORT_LOG"
        if ((quiet != TRUE)); then
            echo "INFO: $@" >&1
        fi
    fi
}

# @brief log summary message
# @param message
function log_summary()
{
    echo "$@" >> "$name_dir/$SUMMARY_LOG"
    if ((quiet != TRUE)); then
        echo "$@" >&1
    fi
}

# @brief Main function
function main()
{
    #initialize the global variables and
    #create storage locations
    init_global
    result=$?
    if [[ ${result} -ne $SUCCESS ]]; then
        echo $(date -u)" Error: Failed to initialize, Exiting"
        exit;
    fi

    #Initilize the summary log
    init_summary

    #TODO Add Dump report generating script.

    package  #package the dump
}

TEMP=`getopt -o n:d:i:t:s:f:vVqh \
      --long name:,dir:,dumpid:,type:,size:,file:,verbose,version,quiet,help \
      -- "$@"`

if [ $? -ne 0 ]
then
    echo "Error: Invalid options"
    exit 1
fi

eval set -- "$TEMP"

while [[ $# -gt 1 ]]; do
    key="$1"
    case $key in
        -n|--name)
            name=$2
            shift 2;;
        -d|--dir)
            dump_dir=$2
            shift 2;;
        -i|--dumpid)
            dump_id=$2
            shift 2;;
        -t|--type)
            dump_type=$2
            shift 2;;
        -s|--size)
            dump_size=$2
            shift 2;;
        -f|--file)
            dump_file=$2
            shift 2;;
        -v|—-verbose)
            verbose=$TRUE
            shift;;
        -V|--version)
            shift;;
        -q|—-quiet)
            quiet=$TRUE
            shift;;
        -h|--help)
            echo "$help"
            exit;;
        *) # unknown option
            log_error "Unknown argument: $1"
            log_info "$help"
            exit 1;;
    esac
done

main #main program
exit $?
